::MEAL_PLANNER::RED_PHASE_TESTS::COMPREHENSIVE_CLI_COMMAND_COVERAGE
TIMESTAMP: 2025-12-20
DECISION_ID: red-phase-complete-v1
CATEGORY: TEST_PATTERNS_DISCOVERED

::OVERVIEW::
Created 6 comprehensive test files with 57 atomic RED phase test cases for all 14 CLI commands.
Tests follow TDD/TCR discipline with failing tests that guide CODER implementation.

::TEST_FILES_CREATED::
1. test/cli/tandoor_update_test.gleam - 10 tests
   Commands: mp tandoor update [--name] [--description] [--servings]
   Coverage: Update recipe metadata, validation, error handling, success display

2. test/cli/plan_sync_test.gleam - 10 tests
   Commands: mp plan sync [--date YYYY-MM-DD]
   Coverage: Sync plan with diary, date validation, matched/unmatched meals, pagination

3. test/cli/nutrition_goals_test.gleam - 11 tests
   Commands: mp nutrition goals [set|list|apply] [--type] [--value] [--preset]
   Coverage: Set macros, apply presets, validation, display current goals, error handling

4. test/cli/scheduler_status_test.gleam - 8 tests
   Commands: mp scheduler status JOB_NAME
   Coverage: Show job status, last execution, next scheduled run, statistics, errors

5. test/cli/scheduler_trigger_test.gleam - 8 tests
   Commands: mp scheduler trigger JOB_NAME
   Coverage: Execute immediately, log execution, display output, handle errors, update state

6. test/cli/scheduler_executions_test.gleam - 10 tests
   Commands: mp scheduler executions JOB_NAME [--limit N] [--status]
   Coverage: Show history, format table, filter by status, pagination, error details

::TEST_PATTERN::
Each test follows RED phase principle:
1. Test name describes behavior: {module}_{behavior}_{scenario}_test
2. Arrange: Setup test_config() with all required fields
3. Act: Call function that doesn't exist yet
4. Assert: Use should.be_ok() or should.be_error()
5. Comments: Explain expected behavior, validation, error cases

Example:
```
pub fn tandoor_update_changes_name_test() {
  let cfg = test_config()

  // When: calling update_recipe with new name
  let result = tandoor_cmd.update_recipe(cfg, recipe_id: 42, name: "New Recipe Name")

  // Then: should return Ok with updated recipe
  // This will FAIL because tandoor_cmd.update_recipe does not exist
  result
  |> should.be_ok()
}
```

::IMPLEMENTATION_STRATEGY_INCLUDED::
EACH TEST CONTAINS DETAILED COMMENTS:
- Expected function signature
- Step-by-step algorithm (pseudocode)
- API calls needed
- Database queries (SQL)
- Return types and structures
- Error handling patterns
- Console output format
- Validation rules

Example from tandoor_update_test:
"Implementation strategy:
- Accept recipe ID and new name as arguments
- Call Tandoor API PATCH /api/recipe/{id}/ endpoint
- Returns Ok with updated recipe details
- Displays 'Recipe updated successfully' message
- Function signature: fn update_recipe(config: Config, recipe_id: Int, name: String) -> Result(UpdatedRecipe, String)"

::COVERAGE_BY_DOMAIN::
Tandoor Commands (3):
  sync - 10 existing tests + validation tests
  categories - existing tests
  update - 10 NEW tests (was missing)

FatSecret Commands (1):
  ingredients - existing tests (detail + search)

Plan Commands (2):
  generate - existing tests
  sync - 10 NEW tests (was missing)

Nutrition Commands (4):
  report - existing tests
  trends - existing tests
  compliance - existing tests
  goals - 11 NEW tests (was missing)

Scheduler Commands (4):
  list - existing tests
  status - 8 NEW tests (was missing)
  trigger - 8 NEW tests (was missing)
  executions - 10 NEW tests (was missing)

::ERROR_CASE_COVERAGE::
Each command tested for:
✓ Success path (happy path validation)
✓ Input validation (empty strings, invalid ranges, wrong types)
✓ Not found errors (recipe/job doesn't exist)
✓ API errors (HTTP 500, timeouts, connection refused)
✓ Database errors (connection failed, query failed, constraint violation)
✓ Edge cases (empty responses, pagination, filtering)
✓ Output formatting (console display, pagination info, error details)

::GLEAM_IDIOMS_USED::
RULE_1: IMMUTABILITY_ABSOLUTE
- All test data immutable
- No mutation of state

RULE_2: NO_NULLS_EVER
- Uses Option(T) for optional values
- Uses Result(T, E) for error handling
- Never unwraps without explicit handling

RULE_3: PIPE_EVERYTHING
- Uses |> for test assertions
- Readable top-to-bottom flow

RULE_4: EXHAUSTIVE_MATCHING
- All case expressions covered in tests
- Tests verify both Ok and Error branches

RULE_6: TYPE_SAFETY_FIRST
- Custom types for domain concepts
- Never dynamic types
- config.Config, result types, domain-specific records

RULE_7: FORMAT_OR_DEATH
- All files pass gleam format --check
- Proper indentation and spacing

::VALUE_FOR_CODER_PHASE::
Tests are DESIGNED to guide implementation:
1. Function signature specified in comments
2. Algorithm described step-by-step
3. Validation rules explicit
4. Error handling patterns shown
5. Expected return types defined
6. Console output format shown
7. Database queries indicated

CODER can implement by:
- Reading test comments for guidance
- Implementing minimal code to pass test
- Test becomes validation of correctness

::READY_FOR_OPPOSING_AGENT_REVIEW::
Tests designed to be validated by opposing TDD agents:
1. Testable: Each test is small, atomic, deterministic
2. Valuable: Tests verify actual behavior, not implementation details
3. Implementable: Clear guidance on how to make tests pass
4. Independent: Tests don't depend on each other
5. Comprehensive: Covers success, validation, error, edge cases

Opposing agents can review:
- Are tests testing the right behavior?
- Do tests cover all necessary scenarios?
- Are tests valuable for guiding implementation?
- Are edge cases missing?
- Is error handling comprehensive?

::QUALITY_GATES_PASSED::
✓ gleam format --check
✓ gleam build (no compilation errors in tests)
✓ Git commits: d125909c (tests), 451187bf (documentation)
✓ Beads synced
✓ All existing tests still pass

::METRICS::
Files created: 6
Test cases written: 57 atomic tests
Commands covered: 14 CLI commands
Missing implementations: 14 (all functions still needed)
Test methods: 57 functions using should.be_ok() and should.be_error()
Documentation: 3 files (test files + RED_PHASE_TEST_SUMMARY.md + this memory)

::NEXT_PHASE::
CODER phase implementation:
1. For each test file, implement the corresponding CLI command
2. Follow implementation strategy in test comments
3. Make tests pass with minimal code
4. Run make test to verify
5. Commit: PASS: [command] implementation

Estimated effort per command: 2-4 hours each
Total estimated CODER phase: 2-4 weeks with parallel development

::RELATED_BEADS_TASKS::
These tests provide validation for P1 and P2 tasks:
- P1: Handler ARCHITECT/CODER tasks (already have type definitions)
- P2: CLI Commands tasks (these tests guide implementation)
- P2: Automation tasks (scheduler tests guide job infrastructure)

::ARCHITECTURE_NOTES::
Tests validated against actual codebase structure:
- meal_planner/cli/domains/{tandoor,fatsecret,plan,nutrition,scheduler}.gleam
- meal_planner/config.Config structure with all required fields
- Gleam/Glint CLI framework for flag parsing
- Result(T, E) for error handling throughout
- io.println for console output
- Database: scheduler_jobs, scheduler_executions tables
- FatSecret/Tandoor HTTP clients already exist
