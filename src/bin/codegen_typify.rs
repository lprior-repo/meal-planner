use schemars::schema::Schema;
use schemars::schema_for;
use serde_json::Value;
use std::fs;
use typify::TypeSpace;

#[derive(schemars::JsonSchema)]
#[allow(dead_code)]
struct JsonSchemaHolder {
    #[schemars(skip)]
    value: Value,
}

#[allow(clippy::no_effect_underscore_binding)]
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let schema_path = std::env::args()
        .nth(1)
        .unwrap_or_else(|| "target/fatsecret_schema.json".to_string());
    let output_path = std::env::args()
        .nth(2)
        .unwrap_or_else(|| "src/api/fatsecret_types.rs".to_string());

    let schema_content = fs::read_to_string(&schema_path)?;
    let schema_value: Value = serde_json::from_str(&schema_content)?;

    let _holder = JsonSchemaHolder {
        value: schema_value,
    };
    let root_schema = schema_for!(JsonSchemaHolder);

    let schema = Schema::Object(root_schema.schema);

    let settings = typify::TypeSpaceSettings::default();

    let mut type_space = TypeSpace::new(&settings);
    type_space.add_type(&schema)?;

    let tokens = type_space.to_stream();

    let mut output = String::new();
    output.push_str("// Auto-generated by typify from CUE schema\n");
    output.push_str("// Do not edit manually\n\n");
    output.push_str("use serde::{Deserialize, Serialize};\n\n");

    output.push_str(&tokens.to_string());
    output.push('\n');

    fs::write(&output_path, &output)?;
    println!("Generated {}", output_path);

    Ok(())
}
