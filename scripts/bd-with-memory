#!/usr/bin/env bash
# Enhanced bd command wrapper with memory integration
# Usage: bd-with-memory [bd command args]

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
MEMORY_LOG="${BEADS_DIR:-.beads}/memory.log"
MEMORY_PROMPTS="${BEADS_DIR:-.beads}/memory_prompts.txt"

# Helper: Print colored output
info() { echo -e "${BLUE}[INFO]${NC} $*"; }
success() { echo -e "${GREEN}[SUCCESS]${NC} $*"; }
warning() { echo -e "${YELLOW}[WARNING]${NC} $*"; }
error() { echo -e "${RED}[ERROR]${NC} $*"; }

# Helper: Log memory operation
log_memory() {
  local operation="$1"
  local task_id="$2"
  local timestamp=$(date -Iseconds)
  echo "${timestamp} | ${operation} | ${task_id}" >> "${MEMORY_LOG}"
}

# Helper: Extract task metadata
get_task_metadata() {
  local task_id="$1"
  bd show "${task_id}" --format json 2>/dev/null || echo "{}"
}

# Helper: Search memories for context
search_context() {
  local query="$1"
  info "Searching memories: ${query}"

  # Use OpenCode MCP to search local-graph
  # Note: Requires mem0 MCP server running
  # Example: search_memory_facts("${query}")

  # For now, show placeholder until MCP integration complete
  warning "Memory search not yet integrated (requires mem0 MCP server)"
  info "Would search for: ${query}"
}

# Helper: Prompt for memory capture
prompt_memory_capture() {
  local task_id="$1"
  local task_title="$2"

  info "Task complete: ${task_id}"
  echo ""
  echo "=== Memory Capture Prompts ==="
  echo ""
  echo "Did this task involve any of the following?"
  echo ""
  echo "1. Architecture Decision"
  echo "   Format: meal-planner: [Component] uses [Pattern] instead of [Alternative] - rationale: [Why]"
  echo ""
  echo "2. Bug Fix"
  echo "   Format: meal-planner: [Component] bug - cause: [Root cause], fix: [Solution], impact: [Scope]"
  echo ""
  echo "3. Code Consolidation"
  echo "   Format: meal-planner: [Category] update - [What changed], [Why], [Files affected]"
  echo ""
  echo "4. Test Pattern"
  echo "   Format: meal-planner: test pattern - [Name], usage: [When to use], pattern: [Code snippet]"
  echo ""
  echo "5. Gleam Idiom"
  echo "   Format: meal-planner: gleam idiom - [Pattern name], do: [What to do], avoid: [What not to do]"
  echo ""
  echo "=== Review Changes ==="
  echo ""

  # Show git changes
  git diff --stat HEAD~1 2>/dev/null || warning "No git changes detected"
  echo ""

  echo "If any apply, capture memory using:"
  echo "  save_memory([formatted_entry])"
  echo ""
  echo "See MEMORY_EXAMPLES.md for templates"
  echo ""

  # Save prompt to file for later reference
  {
    echo "=== ${task_id}: ${task_title} ==="
    echo "Timestamp: $(date -Iseconds)"
    echo ""
    echo "Review questions:"
    echo "- Architecture decision?"
    echo "- Bug fixed?"
    echo "- Code consolidated?"
    echo "- Test pattern created?"
    echo "- Gleam idiom learned?"
    echo ""
    echo "Git changes:"
    git diff --stat HEAD~1 2>/dev/null || echo "No changes"
    echo ""
    echo "---"
    echo ""
  } >> "${MEMORY_PROMPTS}"
}

# Main: Handle bd commands
main() {
  local cmd="${1:-}"

  case "${cmd}" in
    update)
      # Check if setting status to in_progress
      if [[ "${3:-}" == "--status" && "${4:-}" == "in_progress" ]]; then
        local task_id="${2}"

        info "Starting task: ${task_id}"

        # Extract task metadata
        local metadata=$(get_task_metadata "${task_id}")
        local title=$(echo "${metadata}" | jq -r '.title // "Unknown"')

        info "Task: ${title}"
        echo ""

        # Search for context
        search_context "${task_id}"
        search_context "${title}"

        # Check for component-specific context
        if [[ "${title}" =~ tandoor ]]; then
          search_context "tandoor handlers"
        fi
        if [[ "${title}" =~ auth ]]; then
          search_context "auth module"
        fi
        if [[ "${title}" =~ test ]]; then
          search_context "test pattern"
        fi

        echo ""
        log_memory "task_start" "${task_id}"
      fi

      # Execute original bd command
      bd "$@"
      ;;

    close)
      local task_id="${2}"
      local reason="${4:-Completed}"

      # Extract task metadata
      local metadata=$(get_task_metadata "${task_id}")
      local title=$(echo "${metadata}" | jq -r '.title // "Unknown"')

      echo ""
      success "Closing task: ${task_id}"
      echo ""

      # Prompt for memory capture
      prompt_memory_capture "${task_id}" "${title}"

      log_memory "task_close" "${task_id}"

      # Execute original bd command
      bd "$@"

      echo ""
      success "Task closed. Review memory prompts in: ${MEMORY_PROMPTS}"
      ;;

    *)
      # Pass through to bd for all other commands
      bd "$@"
      ;;
  esac
}

# Entry point
if [ $# -eq 0 ]; then
  error "Usage: bd-with-memory [bd command args]"
  echo ""
  echo "Examples:"
  echo "  bd-with-memory ready"
  echo "  bd-with-memory update bd-xxx --status in_progress"
  echo "  bd-with-memory close bd-xxx --reason 'Completed'"
  echo ""
  exit 1
fi

main "$@"
