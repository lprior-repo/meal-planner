/// NCP Alerts - Alert generation and notification system
///
/// Handles alert creation, prioritization, and delivery for the
/// Nutrition Control Plane. Supports multiple notification channels.
///
import gleam/int
import gleam/list
import gleam/option.{type Option, None, Some}
import gleam/string
import meal_planner/email.{type EmailPayload, EmailAddress, EmailPayload}

/// Alert severity levels (following Kubernetes patterns)
pub type AlertLevel {
  /// Informational - suggestions, status updates
  Info
  /// Warning - deviation above threshold, attention needed
  Warning
  /// Critical - significant deviation, immediate action required
  Critical
}

/// An alert generated by the control plane
pub type Alert {
  Alert(
    level: AlertLevel,
    source: String,
    message: String,
    timestamp: String,
  )
}

/// Create a new alert
pub fn new_alert(level: AlertLevel, source: String, message: String) -> Alert {
  Alert(level: level, source: source, message: message, timestamp: get_timestamp())
}

/// Get alert level as string
pub fn level_to_string(level: AlertLevel) -> String {
  case level {
    Critical -> "CRITICAL"
    Warning -> "WARNING"
    Info -> "INFO"
  }
}

/// Get alert priority (lower = more urgent)
pub fn level_priority(level: AlertLevel) -> Int {
  case level {
    Critical -> 1
    Warning -> 2
    Info -> 3
  }
}

/// Sort alerts by priority (most urgent first)
pub fn sort_by_priority(alerts: List(Alert)) -> List(Alert) {
  list.sort(alerts, fn(a, b) {
    int.compare(level_priority(a.level), level_priority(b.level))
  })
}

/// Filter alerts by minimum level
pub fn filter_by_level(alerts: List(Alert), min_level: AlertLevel) -> List(Alert) {
  let min_priority = level_priority(min_level)
  list.filter(alerts, fn(a) { level_priority(a.level) <= min_priority })
}

/// Format alert for display
pub fn format_alert(alert: Alert) -> String {
  "["
  <> level_to_string(alert.level)
  <> "] "
  <> alert.timestamp
  <> " - "
  <> alert.source
  <> ": "
  <> alert.message
}

/// Format multiple alerts for display
pub fn format_alerts(alerts: List(Alert)) -> String {
  alerts
  |> sort_by_priority
  |> list.map(format_alert)
  |> string.join("\n")
}

/// Create email payload from alerts
pub fn alerts_to_email_payload(
  alerts: List(Alert),
  to_email: String,
  from_email: String,
) -> EmailPayload {
  let sorted = sort_by_priority(alerts)

  let subject = case sorted {
    [first, ..] ->
      "[NCP "
      <> level_to_string(first.level)
      <> "] Nutrition Alert - "
      <> first.source
    [] -> "[NCP] Nutrition Status Update"
  }

  let body =
    "Nutrition Control Plane Alert Summary\n"
    <> "=====================================\n\n"
    <> format_alerts(sorted)
    <> "\n\n"
    <> "---\n"
    <> "This is an automated message from your Nutrition Control Plane.\n"
    <> "Review your meal plan and take corrective action if needed.\n"

  EmailPayload(
    from: EmailAddress(email: from_email, name: "Nutrition Control Plane"),
    to: [EmailAddress(email: to_email, name: "")],
    subject: subject,
    text: body,
    category: "ncp_alert",
  )
}

/// Send alert email via Mailtrap
pub fn send_alert_email(
  alerts: List(Alert),
  to_email: String,
  api_token: String,
) -> Result(String, String) {
  let from_email = "ncp@mealplanner.local"
  let payload = alerts_to_email_payload(alerts, to_email, from_email)
  email.send_email(payload, api_token)
}

/// Create a protein deficit alert
pub fn protein_deficit_alert(deficit_pct: Float) -> Alert {
  let level = case deficit_pct {
    p if p >=. 20.0 -> Critical
    p if p >=. 10.0 -> Warning
    _ -> Info
  }
  new_alert(
    level,
    "protein_tracking",
    "Protein intake is " <> float_to_pct(deficit_pct) <> " below target",
  )
}

/// Create a calorie surplus alert
pub fn calorie_surplus_alert(surplus_pct: Float) -> Alert {
  let level = case surplus_pct {
    p if p >=. 20.0 -> Critical
    p if p >=. 10.0 -> Warning
    _ -> Info
  }
  new_alert(
    level,
    "calorie_tracking",
    "Calorie intake is " <> float_to_pct(surplus_pct) <> " above target",
  )
}

/// Create a meal suggestion alert
pub fn meal_suggestion_alert(recipe_names: List(String)) -> Alert {
  new_alert(
    Info,
    "meal_suggestions",
    "Recommended meals to meet targets: " <> string.join(recipe_names, ", "),
  )
}

/// Create a consistency alert
pub fn consistency_alert(days_off_track: Int) -> Alert {
  let level = case days_off_track {
    d if d >= 3 -> Critical
    d if d >= 2 -> Warning
    _ -> Info
  }
  new_alert(
    level,
    "consistency",
    "You've been off-track for "
      <> int.to_string(days_off_track)
      <> " day(s). Consider meal prep!",
  )
}

/// Create an on-track celebration alert
pub fn on_track_alert(days_on_track: Int) -> Alert {
  new_alert(
    Info,
    "consistency",
    "Great job! "
      <> int.to_string(days_on_track)
      <> " day streak of hitting your targets!",
  )
}

// Helper functions

fn get_timestamp() -> String {
  let #(year, month, day) = erlang_date()
  let #(hour, min, sec) = erlang_time()
  int.to_string(year)
  <> "-"
  <> pad_int(month)
  <> "-"
  <> pad_int(day)
  <> " "
  <> pad_int(hour)
  <> ":"
  <> pad_int(min)
  <> ":"
  <> pad_int(sec)
}

fn pad_int(n: Int) -> String {
  case n < 10 {
    True -> "0" <> int.to_string(n)
    False -> int.to_string(n)
  }
}

fn float_to_pct(f: Float) -> String {
  let rounded = float_round(f *. 10.0)
  let int_part = rounded / 10
  let dec_part = int_absolute(rounded) % 10
  int.to_string(int_part) <> "." <> int.to_string(dec_part) <> "%"
}

@external(erlang, "erlang", "date")
fn erlang_date() -> #(Int, Int, Int)

@external(erlang, "erlang", "time")
fn erlang_time() -> #(Int, Int, Int)

@external(erlang, "erlang", "round")
fn float_round(f: Float) -> Int

@external(erlang, "erlang", "abs")
fn int_absolute(n: Int) -> Int
