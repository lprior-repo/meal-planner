/// NCP (Nutrition Control Plane) types for nutrition tracking and reconciliation

import gleam/float
import gleam/int
import gleam/list
import gleam/string
import shared/types.{type Macros}

/// NutritionGoals represents daily macro targets
pub type NutritionGoals {
  NutritionGoals(
    daily_protein: Float,
    daily_fat: Float,
    daily_carbs: Float,
    daily_calories: Float,
  )
}

/// NutritionData represents nutrition values (for a day or meal)
pub type NutritionData {
  NutritionData(protein: Float, fat: Float, carbs: Float, calories: Float)
}

/// DeviationResult represents percentage deviation from goals
pub type DeviationResult {
  DeviationResult(
    protein_pct: Float,
    fat_pct: Float,
    carbs_pct: Float,
    calories_pct: Float,
  )
}

/// RecipeSuggestion represents a recommended recipe to address nutritional deviation
pub type RecipeSuggestion {
  RecipeSuggestion(recipe_name: String, reason: String, score: Float)
}

/// AdjustmentPlan contains recipe suggestions to correct nutritional deviations
pub type AdjustmentPlan {
  AdjustmentPlan(deviation: DeviationResult, suggestions: List(RecipeSuggestion))
}

/// ScoredRecipe represents a recipe with its nutritional macros for scoring
pub type ScoredRecipe {
  ScoredRecipe(name: String, macros: Macros)
}

/// Validate ensures goals are within reasonable ranges
pub fn nutrition_goals_validate(
  goals: NutritionGoals,
) -> Result(NutritionGoals, String) {
  case goals {
    NutritionGoals(protein, _, _, _) if protein <=. 0.0 ->
      Error("daily protein must be positive")
    NutritionGoals(_, fat, _, _) if fat <. 0.0 ->
      Error("daily fat cannot be negative")
    NutritionGoals(_, _, carbs, _) if carbs <. 0.0 ->
      Error("daily carbs cannot be negative")
    NutritionGoals(_, _, _, calories) if calories <=. 0.0 ->
      Error("daily calories must be positive")
    _ -> Ok(goals)
  }
}

/// Calculate percentage deviation between actual and goals
/// Returns positive values for over, negative for under
pub fn calculate_deviation(
  goals: NutritionGoals,
  actual: NutritionData,
) -> DeviationResult {
  DeviationResult(
    protein_pct: calc_pct_deviation(goals.daily_protein, actual.protein),
    fat_pct: calc_pct_deviation(goals.daily_fat, actual.fat),
    carbs_pct: calc_pct_deviation(goals.daily_carbs, actual.carbs),
    calories_pct: calc_pct_deviation(goals.daily_calories, actual.calories),
  )
}

/// Calculate (actual - goal) / goal * 100
fn calc_pct_deviation(goal: Float, actual: Float) -> Float {
  case goal {
    0.0 -> 0.0
    _ -> { actual -. goal } /. goal *. 100.0
  }
}

/// Check if all macro deviations are within the given tolerance
pub fn deviation_is_within_tolerance(
  dev: DeviationResult,
  tolerance_pct: Float,
) -> Bool {
  float.absolute_value(dev.protein_pct) <=. tolerance_pct
  && float.absolute_value(dev.fat_pct) <=. tolerance_pct
  && float.absolute_value(dev.carbs_pct) <=. tolerance_pct
}

/// Returns the maximum absolute deviation across all macros
pub fn deviation_max(dev: DeviationResult) -> Float {
  let protein_abs = float.absolute_value(dev.protein_pct)
  let fat_abs = float.absolute_value(dev.fat_pct)
  let carbs_abs = float.absolute_value(dev.carbs_pct)

  protein_abs
  |> float.max(fat_abs)
  |> float.max(carbs_abs)
}

/// Get nutrition history for specified number of days
pub fn get_nutrition_history(days: Int) -> Result(List(NutritionData), String) {
  // For now, return empty list
  // In full implementation, this would query the database
  Ok([])
}

/// Get default nutrition goals
pub fn get_default_goals() -> NutritionGoals {
  NutritionGoals(
    daily_protein: 180.0,
    daily_fat: 60.0,
    daily_carbs: 250.0,
    daily_calories: 2500.0,
  )
}

/// Run reconciliation analysis on nutrition data
pub fn run_reconciliation(
  history: List(NutritionData),
  goals: NutritionGoals,
  tolerance_pct: Float,
  max_suggestions: Int,
) -> AdjustmentPlan {
  // For now, create a simple plan
  // In full implementation, this would analyze history vs goals
  let avg_data = calculate_average_nutrition(history)
  let deviation = calculate_deviation(goals, avg_data)
  
  let suggestions = case deviation_max(deviation) >. tolerance_pct {
    True -> [
      RecipeSuggestion(
        recipe_name: "Increase Protein",
        reason: "Protein intake below target",
        score: 25.0,
      )
    ]
    False -> []
  }
  
  AdjustmentPlan(deviation: deviation, suggestions: suggestions)
}

/// Calculate average nutrition from history
fn calculate_average_nutrition(history: List(NutritionData)) -> NutritionData {
  case history {
    [] -> NutritionData(protein: 0.0, fat: 0.0, carbs: 0.0, calories: 0.0)
    _ -> {
      let count = int_to_float(list.length(history))
      let sum = list.fold(history, NutritionData(protein: 0.0, fat: 0.0, carbs: 0.0, calories: 0.0), fn(acc, data) {
        NutritionData(
          protein: acc.protein +. data.protein,
          fat: acc.fat +. data.fat,
          carbs: acc.carbs +. data.carbs,
          calories: acc.calories +. data.calories,
        )
      })
      
      NutritionData(
        protein: sum.protein /. count,
        fat: sum.fat /. count,
        carbs: sum.carbs /. count,
        calories: sum.calories /. count,
      )
    }
  }
}

/// Format status output for display
pub fn format_status_output(plan: AdjustmentPlan) -> String {
  "=== Nutrition Status ===\n"
  <> "Protein: " <> float_to_string(plan.deviation.protein_pct) <> "% from target\n"
  <> "Fat: " <> float_to_string(plan.deviation.fat_pct) <> "% from target\n"
  <> "Carbs: " <> float_to_string(plan.deviation.carbs_pct) <> "% from target\n"
  <> "Calories: " <> float_to_string(plan.deviation.calories_pct) <> "% from target\n"
}

/// Format reconciliation output for display
pub fn format_reconcile_output(plan: AdjustmentPlan) -> String {
  let base = format_status_output(plan)
  
  case list.is_empty(plan.suggestions) {
    True -> base <> "\nNo adjustments needed - within tolerance!"
    False -> {
      let suggestions_str = list.map(plan.suggestions, fn(s) {
        "- " <> s.recipe_name <> ": " <> s.reason
      }) |> string.join("\n")
      
      base <> "\n\nSuggestions:\n" <> suggestions_str
    }
  }
}

/// Convert float to string
fn float_to_string(f: Float) -> String {
  string.from_float(f)
}

/// Convert int to float
@external(erlang, "erlang", "float")
fn int_to_float(n: Int) -> Float

/// List length function
fn list_length(list: List(a)) -> Int {
  case list {
    [] -> 0
    [_, ..rest] -> 1 + list_length(rest)
  }
}

/// List fold function
fn list_fold(list: List(a), acc: b, f: fn(b, a) -> b) -> b {
  case list {
    [] -> acc
    [first, ..rest] -> list_fold(rest, f(acc, first), f)
  }
}

// ============================================================================
// Recipe Scoring and Selection Functions
// ============================================================================

/// Score a recipe for how well it addresses a nutritional deviation
/// Returns a score from 0.0 to 1.0, where higher scores indicate better fit
/// Prioritizes protein, then considers overall macro balance
pub fn score_recipe_for_deviation(
  deviation: DeviationResult,
  macros: Macros,
) -> Float {
  let total_deviation = 
    float.absolute_value(deviation.protein_pct) 
    +. float.absolute_value(deviation.fat_pct) 
    +. float.absolute_value(deviation.carbs_pct)
  
  case total_deviation <. 5.0 {
    True -> 0.1
    False -> {
      // If over on all macros, adding food is bad
      case deviation.protein_pct >. 0.0 && deviation.fat_pct >. 0.0 && deviation.carbs_pct >. 0.0 {
        True -> 0.1
        False -> {
          let score = calculate_base_score(deviation, macros)
          |> apply_protein_scoring(deviation, macros)
          |> apply_fat_scoring(deviation, macros)
          |> apply_carb_scoring(deviation, macros)
          
          score
          |> float.clamp(0.0, 1.0)
        }
      }
    }
  }
}

/// Calculate base score for recipe against deviation
fn calculate_base_score(deviation: DeviationResult, macros: Macros) -> Float {
  0.0
}

/// Apply protein scoring (weight: 0.5)
fn apply_protein_scoring(
  deviation: DeviationResult, 
  macros: Macros, 
  current_score: Float
) -> Float {
  case deviation.protein_pct <. 0.0 && macros.protein >. 0.0 {
    True -> {
      // Recipe helps address protein deficit
      let protein_score = float.min(macros.protein /. 40.0, 1.0) // Normalize: 40g protein = max score
      current_score +. 0.5 *. protein_score
    }
    False -> current_score
  }
}

/// Apply fat scoring (weight: 0.25)
fn apply_fat_scoring(
  deviation: DeviationResult, 
  macros: Macros, 
  current_score: Float
) -> Float {
  case deviation.fat_pct <. 0.0 && macros.fat >. 0.0 {
    True -> {
      let fat_score = float.min(macros.fat /. 25.0, 1.0) // Normalize: 25g fat = max score
      current_score +. 0.25 *. fat_score
    }
    False -> {
      // Penalize high fat when already over
      case deviation.fat_pct >. 10.0 && macros.fat >. 20.0 {
        True -> current_score -. 0.1
        False -> current_score
      }
    }
  }
}

/// Apply carb scoring (weight: 0.25)
fn apply_carb_scoring(
  deviation: DeviationResult, 
  macros: Macros, 
  current_score: Float
) -> Float {
  case deviation.carbs_pct <. 0.0 && macros.carbs >. 0.0 {
    True -> {
      let carbs_score = float.min(macros.carbs /. 50.0, 1.0) // Normalize: 50g carbs = max score
      current_score +. 0.25 *. carbs_score
    }
    False -> {
      // Penalize high carbs when already over
      case deviation.carbs_pct >. 10.0 && macros.carbs >. 30.0 {
        True -> current_score -. 0.1
        False -> current_score
      }
    }
  }
}

/// Select top recipes by score against a deviation
pub fn select_top_recipes(
  deviation: DeviationResult,
  recipes: List(ScoredRecipe),
  limit: Int,
) -> List(RecipeSuggestion) {
  case recipes {
    [] -> []
    _ -> {
      // Score all recipes
      let scored = list.map(recipes, fn(r) {
        let score = score_recipe_for_deviation(deviation, r.macros)
        #(r, score)
      })
      
      // Sort by score descending
      let sorted = list.sort(scored, fn(a, b) {
        let #(_, score_a) = a
        let #(_, score_b) = b
        float.compare(score_b, score_a) // Descending order
      })
      
      // Take top N
      let limited = list.take(sorted, limit)
      
      // Convert to suggestions
      list.map(limited, fn(item) {
        let #(recipe, score) = item
        RecipeSuggestion(
          recipe_name: recipe.name,
          reason: generate_reason(deviation, recipe.macros),
          score: score,
        )
      })
    }
  }
}

/// Generate a human-readable reason for recipe suggestion
pub fn generate_reason(deviation: DeviationResult, macros: Macros) -> String {
  case deviation.protein_pct <. -10.0 && macros.protein >. 20.0 {
    True -> "High protein to address deficit"
    False -> {
      case deviation.carbs_pct <. -10.0 && macros.carbs >. 30.0 {
        True -> "Good carbs to address deficit"
        False -> {
          case deviation.fat_pct <. -10.0 && macros.fat >. 15.0 {
            True -> "Healthy fats to address deficit"
            False -> "Balanced macros"
          }
        }
      }
    }
  }
}
