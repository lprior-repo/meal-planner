/// Cache Server - GenServer for managing query cache state
///
/// This module provides a GenServer that holds the application's query cache
/// state and provides a centralized API for cache operations. The cache is
/// initialized on application startup and managed throughout the app lifecycle.
///
/// The cache server registers itself globally so it can be accessed from
/// anywhere in the application without passing references around.
import gleam/erlang/process.{type Subject}
import gleam/option.{None, Some}
import gleam/otp/actor
import meal_planner/query_cache
import meal_planner/storage_optimized.{type SearchCache}

/// Registered name for the cache server
pub const cache_server_name = "meal_planner_cache_server"

// ============================================================================
// Cache Server State and Messages
// ============================================================================

/// Cache server state
pub type CacheState {
  CacheState(cache: SearchCache)
}

/// Messages that can be sent to the cache server
pub type CacheMessage {
  /// Get the current cache (for read-through operations)
  GetCache(reply_with: Subject(SearchCache))
  /// Update the cache with a new version (after cache operations)
  UpdateCache(cache: SearchCache, reply_with: Subject(Nil))
  /// Get cache statistics
  GetStats(reply_with: Subject(query_cache.CacheStats))
  /// Clear the cache
  ClearCache(reply_with: Subject(SearchCache))
  /// Reset cache statistics
  ResetStats(reply_with: Subject(SearchCache))
  /// Shutdown the cache server
  Shutdown
}

// ============================================================================
// Public API
// ============================================================================

/// Start the cache server and register it with a global name
pub fn start() -> actor.StartResult(Subject(CacheMessage)) {
  let initial_cache = storage_optimized.new_search_cache()
  let initial_state = CacheState(cache: initial_cache)

  actor.new(initial_state)
  |> actor.on_message(handle_message)
  |> actor.start
}

/// Look up the cache server by its registered name
///
/// Returns None if the cache server hasn't been started yet
pub fn whereis() -> option.Option(Subject(CacheMessage)) {
  process.named(cache_server_name)
}

/// Get the current cache state from the registered server
///
/// Looks up the server by name, or uses the provided server reference
pub fn get_cache(server: option.Option(Subject(CacheMessage))) -> SearchCache {
  let srv = case server {
    Some(s) -> s
    None ->
      case whereis() {
        Some(s) -> s
        None -> panic as "Cache server not started"
      }
  }
  actor.call(srv, GetCache, 1000)
}

/// Update the cache state
pub fn update_cache(
  server: option.Option(Subject(CacheMessage)),
  cache: SearchCache,
) -> Nil {
  let srv = case server {
    Some(s) -> s
    None ->
      case whereis() {
        Some(s) -> s
        None -> panic as "Cache server not started"
      }
  }
  actor.call(srv, fn(reply) { UpdateCache(cache, reply) }, 1000)
}

/// Get cache statistics
pub fn get_stats(
  server: option.Option(Subject(CacheMessage)),
) -> query_cache.CacheStats {
  let srv = case server {
    Some(s) -> s
    None ->
      case whereis() {
        Some(s) -> s
        None -> panic as "Cache server not started"
      }
  }
  actor.call(srv, GetStats, 1000)
}

/// Clear the cache
pub fn clear_cache(
  server: option.Option(Subject(CacheMessage)),
) -> SearchCache {
  let srv = case server {
    Some(s) -> s
    None ->
      case whereis() {
        Some(s) -> s
        None -> panic as "Cache server not started"
      }
  }
  actor.call(srv, ClearCache, 1000)
}

/// Reset cache statistics
pub fn reset_stats(
  server: option.Option(Subject(CacheMessage)),
) -> SearchCache {
  let srv = case server {
    Some(s) -> s
    None ->
      case whereis() {
        Some(s) -> s
        None -> panic as "Cache server not started"
      }
  }
  actor.call(srv, ResetStats, 1000)
}

/// Shutdown the cache server
pub fn shutdown(server: option.Option(Subject(CacheMessage))) -> Nil {
  let srv = case server {
    Some(s) -> s
    None ->
      case whereis() {
        Some(s) -> s
        None -> panic as "Cache server not started"
      }
  }
  process.send(srv, Shutdown)
}

// ============================================================================
// Message Handlers
// ============================================================================

/// Handle incoming messages
fn handle_message(
  state: CacheState,
  message: CacheMessage,
) -> actor.Next(CacheState, CacheMessage) {
  case message {
    GetCache(reply_with:) -> {
      actor.send(reply_with, state.cache)
      actor.continue(state)
    }

    UpdateCache(new_cache, reply_with:) -> {
      actor.send(reply_with, Nil)
      actor.continue(CacheState(cache: new_cache))
    }

    GetStats(reply_with:) -> {
      let stats = query_cache.get_stats(state.cache)
      actor.send(reply_with, stats)
      actor.continue(state)
    }

    ClearCache(reply_with:) -> {
      let cleared_cache = query_cache.clear(state.cache)
      actor.send(reply_with, cleared_cache)
      actor.continue(CacheState(cache: cleared_cache))
    }

    ResetStats(reply_with:) -> {
      let reset_cache = query_cache.reset_stats(state.cache)
      actor.send(reply_with, reset_cache)
      actor.continue(CacheState(cache: reset_cache))
    }

    Shutdown -> actor.stop()
  }
}
