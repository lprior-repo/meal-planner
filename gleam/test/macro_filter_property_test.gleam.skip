/// Property-based tests for macro filtering
/// Tests that filtering returns correct subsets of recipes based on macro constraints
///
/// This test suite validates key properties:
/// - All returned recipes match the specified criteria
/// - No matching recipes are excluded (completeness)
/// - Subset relation holds: filtered_count <= total_count
/// - Empty constraints return all recipes
/// - Tighter constraints return smaller or equal subsets
/// - Boundary values are included correctly (>= and <=)
/// - Category filtering works independently
/// - Macro filtering (protein, fat, carbs, calories) works independently
/// - Multiple constraints work together (AND logic)
///
import gleam/list
import gleeunit/should
import meal_planner/recipe_filter.{
  type FilterParams, type FilteredRecipeItem, FilterParams, FilteredRecipeItem,
}

// ============================================================================
// Test Data Fixtures
// ============================================================================

fn high_protein_recipe() -> FilteredRecipeItem {
  FilteredRecipeItem(
    id: "hp-1",
    name: "High Protein",
    category: "main",
    protein: 50.0,
    fat: 10.0,
    carbs: 30.0,
    calories: 490.0,
    servings: 1,
  )
}

fn balanced_recipe() -> FilteredRecipeItem {
  FilteredRecipeItem(
    id: "bal-1",
    name: "Balanced",
    category: "main",
    protein: 30.0,
    fat: 20.0,
    carbs: 50.0,
    calories: 550.0,
    servings: 2,
  )
}

fn high_fat_recipe() -> FilteredRecipeItem {
  FilteredRecipeItem(
    id: "hf-1",
    name: "High Fat",
    category: "sauce",
    protein: 5.0,
    fat: 45.0,
    carbs: 10.0,
    calories: 425.0,
    servings: 1,
  )
}

fn high_carb_recipe() -> FilteredRecipeItem {
  FilteredRecipeItem(
    id: "hc-1",
    name: "High Carb",
    category: "side",
    protein: 8.0,
    fat: 5.0,
    carbs: 75.0,
    calories: 350.0,
    servings: 3,
  )
}

fn low_calorie_recipe() -> FilteredRecipeItem {
  FilteredRecipeItem(
    id: "lc-1",
    name: "Low Calorie",
    category: "side",
    protein: 12.0,
    fat: 2.0,
    carbs: 20.0,
    calories: 128.0,
    servings: 2,
  )
}

fn test_recipes() -> List(FilteredRecipeItem) {
  [
    high_protein_recipe(),
    balanced_recipe(),
    high_fat_recipe(),
    high_carb_recipe(),
    low_calorie_recipe(),
  ]
}

// ============================================================================
// PROPERTY: All returned recipes match the filter criteria
// ============================================================================

pub fn all_returned_recipes_match_criteria_test() {
  // Property: Every recipe in the result must satisfy all filter criteria
  let recipes = test_recipes()
  let params =
    FilterParams(
      category: None,
      min_protein: Some(20.0),
      max_protein: None,
      min_fat: None,
      max_fat: Some(25.0),
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    )

  let filtered = recipe_filter.filter_recipes(recipes, params)

  // Verify every recipe in the result matches criteria
  filtered
  |> list.each(fn(recipe) {
    recipe_filter.matches_criteria(recipe, params) |> should.be_true
  })
}

pub fn all_returned_recipes_match_with_all_constraints_test() {
  // Property: With multiple constraints, all must be satisfied
  let recipes = test_recipes()
  let params =
    FilterParams(
      category: Some("main"),
      min_protein: Some(25.0),
      max_protein: None,
      min_fat: Some(5.0),
      max_fat: Some(25.0),
      min_carbs: Some(25.0),
      max_carbs: Some(60.0),
      min_calories: Some(400.0),
      max_calories: Some(600.0),
    )

  let filtered = recipe_filter.filter_recipes(recipes, params)

  // Verify every recipe in the result matches all criteria
  filtered
  |> list.each(fn(recipe) {
    recipe_filter.matches_criteria(recipe, params) |> should.be_true
  })
}

pub fn all_returned_recipes_match_category_only_test() {
  // Property: Category filtering alone should match all recipes in that category
  let recipes = test_recipes()
  let params =
    FilterParams(
      category: Some("side"),
      min_protein: None,
      max_protein: None,
      min_fat: None,
      max_fat: None,
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    )

  let filtered = recipe_filter.filter_recipes(recipes, params)

  // Should get recipes with category="side"
  filtered |> list.length |> should.equal(2)
  filtered
  |> list.each(fn(_recipe) { _recipe.category |> should.equal("side") })
}

// ============================================================================
// PROPERTY: Subset correctness (no matching recipes excluded)
// ============================================================================

pub fn filtered_count_less_than_or_equal_to_total_test() {
  // Property: filtered_count <= total_count (subset property)
  let recipes = test_recipes()
  let test_cases = [
    FilterParams(
      category: None,
      min_protein: Some(30.0),
      max_protein: None,
      min_fat: None,
      max_fat: None,
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    ),
    FilterParams(
      category: Some("main"),
      min_protein: None,
      max_protein: None,
      min_fat: None,
      max_fat: None,
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    ),
    FilterParams(
      category: None,
      min_protein: None,
      max_protein: None,
      min_fat: None,
      max_fat: Some(10.0),
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    ),
  ]

  let total = list.length(recipes)
  test_cases
  |> list.each(fn(params) {
    let filtered = recipe_filter.filter_recipes(recipes, params)
    let filtered_count = list.length(filtered)
    { filtered_count <=. int.to_float(total) }
    |> should.be_true
  })
}

pub fn no_matching_recipes_excluded_test() {
  // Property: Manual verification that all matching recipes are in the result
  let recipes = test_recipes()
  let params =
    FilterParams(
      category: None,
      min_protein: Some(25.0),
      max_protein: Some(50.0),
      min_fat: None,
      max_fat: None,
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    )

  let filtered = recipe_filter.filter_recipes(recipes, params)

  // Count recipes that should match manually
  let should_match_count =
    recipes
    |> list.filter(fn(recipe) {
      recipe.protein >=. 25.0 && recipe.protein <=. 50.0
    })
    |> list.length

  // Filtered count should equal manually counted matching recipes
  list.length(filtered) |> should.equal(should_match_count)
}

// ============================================================================
// PROPERTY: Empty constraints return all recipes
// ============================================================================

pub fn no_constraints_returns_all_recipes_test() {
  // Property: Empty FilterParams (all None) should return all recipes
  let recipes = test_recipes()
  let params =
    FilterParams(
      category: None,
      min_protein: None,
      max_protein: None,
      min_fat: None,
      max_fat: None,
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    )

  let filtered = recipe_filter.filter_recipes(recipes, params)

  list.length(filtered) |> should.equal(list.length(recipes))
}

pub fn filtering_with_no_constraints_preserves_order_test() {
  // Property: With no constraints, filtered recipes should match original order
  let recipes = test_recipes()
  let params =
    FilterParams(
      category: None,
      min_protein: None,
      max_protein: None,
      min_fat: None,
      max_fat: None,
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    )

  let filtered = recipe_filter.filter_recipes(recipes, params)

  // Should be identical
  filtered |> should.equal(recipes)
}

// ============================================================================
// PROPERTY: Tighter constraints return smaller or equal subsets
// ============================================================================

pub fn tighter_constraint_reduces_or_maintains_results_test() {
  // Property: A tighter constraint should not increase results
  let recipes = test_recipes()

  // Less tight: protein >= 10
  let loose_params =
    FilterParams(
      category: None,
      min_protein: Some(10.0),
      max_protein: None,
      min_fat: None,
      max_fat: None,
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    )

  // Tighter: protein >= 30
  let tight_params =
    FilterParams(
      category: None,
      min_protein: Some(30.0),
      max_protein: None,
      min_fat: None,
      max_fat: None,
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    )

  let loose_filtered = recipe_filter.filter_recipes(recipes, loose_params)
  let tight_filtered = recipe_filter.filter_recipes(recipes, tight_params)

  let loose_count = list.length(loose_filtered)
  let tight_count = list.length(tight_filtered)

  // Tighter constraint should have <= results
  { tight_count <=. int.to_float(loose_count) } |> should.be_true
}

pub fn combining_constraints_reduces_results_test() {
  // Property: Adding more constraints should not increase results
  let recipes = test_recipes()

  // Single constraint: protein >= 20
  let single_params =
    FilterParams(
      category: None,
      min_protein: Some(20.0),
      max_protein: None,
      min_fat: None,
      max_fat: None,
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    )

  // Two constraints: protein >= 20 AND fat <= 20
  let double_params =
    FilterParams(
      category: None,
      min_protein: Some(20.0),
      max_protein: None,
      min_fat: None,
      max_fat: Some(20.0),
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    )

  let single_filtered = recipe_filter.filter_recipes(recipes, single_params)
  let double_filtered = recipe_filter.filter_recipes(recipes, double_params)

  let single_count = list.length(single_filtered)
  let double_count = list.length(double_filtered)

  // More constraints should have <= results
  { double_count <=. int.to_float(single_count) } |> should.be_true
}

// ============================================================================
// PROPERTY: Boundary values are included correctly
// ============================================================================

pub fn minimum_boundary_inclusive_test() {
  // Property: Values equal to min should be included (>= not >)
  let recipes = test_recipes()
  let params =
    FilterParams(
      category: None,
      min_protein: Some(50.0),
      max_protein: None,
      min_fat: None,
      max_fat: None,
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    )

  let filtered = recipe_filter.filter_recipes(recipes, params)

  // Should include the high_protein_recipe with exactly 50.0g protein
  let high_protein = high_protein_recipe()
  filtered
  |> list.find(fn(r) { r.id == high_protein.id })
  |> should.be_ok
}

pub fn maximum_boundary_inclusive_test() {
  // Property: Values equal to max should be included (<= not <)
  let recipes = test_recipes()
  let params =
    FilterParams(
      category: None,
      min_protein: None,
      max_protein: Some(50.0),
      min_fat: None,
      max_fat: None,
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    )

  let filtered = recipe_filter.filter_recipes(recipes, params)

  // Should include the high_protein_recipe with exactly 50.0g protein
  let high_protein = high_protein_recipe()
  filtered
  |> list.find(fn(r) { r.id == high_protein.id })
  |> should.be_ok
}

pub fn exact_match_with_min_equals_max_test() {
  // Property: Setting min = max should match only that exact value
  let recipes = test_recipes()
  let params =
    FilterParams(
      category: None,
      min_protein: Some(30.0),
      max_protein: Some(30.0),
      min_fat: None,
      max_fat: None,
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    )

  let filtered = recipe_filter.filter_recipes(recipes, params)

  // Should match balanced recipe (protein=30.0) and no others
  filtered
  |> list.filter(fn(r) { r.protein >=. 29.5 && r.protein <=. 30.5 })
  |> list.length
  |> should.equal(list.length(filtered))
}

// ============================================================================
// PROPERTY: Independent constraint application
// ============================================================================

pub fn category_filter_independent_test() {
  // Property: Category filtering is independent of macro filtering
  let recipes = test_recipes()

  // Filter by category only
  let category_params =
    FilterParams(
      category: Some("main"),
      min_protein: None,
      max_protein: None,
      min_fat: None,
      max_fat: None,
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    )

  let category_filtered = recipe_filter.filter_recipes(recipes, category_params)

  // All results should have category="main"
  category_filtered
  |> list.each(fn(recipe) { recipe.category |> should.equal("main") })
}

pub fn protein_filter_independent_test() {
  // Property: Protein filtering works independently
  let recipes = test_recipes()
  let params =
    FilterParams(
      category: None,
      min_protein: Some(25.0),
      max_protein: None,
      min_fat: None,
      max_fat: None,
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    )

  let filtered = recipe_filter.filter_recipes(recipes, params)

  // All should have protein >= 25.0
  filtered
  |> list.each(fn(recipe) {
    { recipe.protein >=. 25.0 } |> should.be_true
  })
}

pub fn fat_filter_independent_test() {
  // Property: Fat filtering works independently
  let recipes = test_recipes()
  let params =
    FilterParams(
      category: None,
      min_protein: None,
      max_protein: None,
      min_fat: None,
      max_fat: Some(15.0),
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    )

  let filtered = recipe_filter.filter_recipes(recipes, params)

  // All should have fat <= 15.0
  filtered
  |> list.each(fn(recipe) {
    { recipe.fat <=. 15.0 } |> should.be_true
  })
}

pub fn carbs_filter_independent_test() {
  // Property: Carbs filtering works independently
  let recipes = test_recipes()
  let params =
    FilterParams(
      category: None,
      min_protein: None,
      max_protein: None,
      min_fat: None,
      max_fat: None,
      min_carbs: Some(15.0),
      max_carbs: Some(55.0),
      min_calories: None,
      max_calories: None,
    )

  let filtered = recipe_filter.filter_recipes(recipes, params)

  // All should have 15 <= carbs <= 55
  filtered
  |> list.each(fn(recipe) {
    { recipe.carbs >=. 15.0 && recipe.carbs <=. 55.0 } |> should.be_true
  })
}

pub fn calories_filter_independent_test() {
  // Property: Calories filtering works independently
  let recipes = test_recipes()
  let params =
    FilterParams(
      category: None,
      min_protein: None,
      max_protein: None,
      min_fat: None,
      max_fat: None,
      min_carbs: None,
      max_carbs: None,
      min_calories: Some(300.0),
      max_calories: None,
    )

  let filtered = recipe_filter.filter_recipes(recipes, params)

  // All should have calories >= 300.0
  filtered
  |> list.each(fn(recipe) {
    { recipe.calories >=. 300.0 } |> should.be_true
  })
}

// ============================================================================
// PROPERTY: Multiple constraints work together (AND logic)
// ============================================================================

pub fn multiple_constraints_and_logic_test() {
  // Property: Multiple constraints are combined with AND (all must be true)
  let recipes = test_recipes()
  let params =
    FilterParams(
      category: Some("main"),
      min_protein: Some(25.0),
      max_protein: None,
      min_fat: Some(5.0),
      max_fat: Some(25.0),
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    )

  let filtered = recipe_filter.filter_recipes(recipes, params)

  // All must satisfy ALL constraints
  filtered
  |> list.each(fn(recipe) {
    // Category
    { recipe.category == "main" } |> should.be_true
    // Protein
    { recipe.protein >=. 25.0 } |> should.be_true
    // Fat range
    { recipe.fat >=. 5.0 && recipe.fat <=. 25.0 } |> should.be_true
  })
}

pub fn multiple_constraints_with_four_macros_test() {
  // Property: All four macros can be constrained simultaneously
  let recipes = test_recipes()
  let params =
    FilterParams(
      category: None,
      min_protein: Some(20.0),
      max_protein: Some(60.0),
      min_fat: Some(5.0),
      max_fat: Some(30.0),
      min_carbs: Some(20.0),
      max_carbs: Some(60.0),
      min_calories: Some(400.0),
      max_calories: Some(600.0),
    )

  let filtered = recipe_filter.filter_recipes(recipes, params)

  // All must satisfy all four macro constraints
  filtered
  |> list.each(fn(recipe) {
    { recipe.protein >=. 20.0 && recipe.protein <=. 60.0 }
    |> should.be_true
    { recipe.fat >=. 5.0 && recipe.fat <=. 30.0 } |> should.be_true
    { recipe.carbs >=. 20.0 && recipe.carbs <=. 60.0 } |> should.be_true
    { recipe.calories >=. 400.0 && recipe.calories <=. 600.0 } |> should.be_true
  })
}

// ============================================================================
// PROPERTY: Filtering is idempotent (filtering a filtered result gives same result)
// ============================================================================

pub fn filtering_twice_with_same_params_is_idempotent_test() {
  // Property: filter(filter(recipes, p), p) == filter(recipes, p)
  let recipes = test_recipes()
  let params =
    FilterParams(
      category: None,
      min_protein: Some(20.0),
      max_protein: None,
      min_fat: None,
      max_fat: None,
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    )

  let filtered_once = recipe_filter.filter_recipes(recipes, params)
  let filtered_twice = recipe_filter.filter_recipes(filtered_once, params)

  filtered_once |> should.equal(filtered_twice)
}

// ============================================================================
// PROPERTY: Inverse relationship (contradictory constraints)
// ============================================================================

pub fn contradictory_constraints_return_empty_test() {
  // Property: min > max should return no recipes
  let recipes = test_recipes()
  let params =
    FilterParams(
      category: None,
      min_protein: Some(100.0),
      max_protein: Some(50.0),
      min_fat: None,
      max_fat: None,
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    )

  let filtered = recipe_filter.filter_recipes(recipes, params)

  list.length(filtered) |> should.equal(0)
}

pub fn impossible_category_returns_empty_test() {
  // Property: Non-existent category returns no recipes
  let recipes = test_recipes()
  let params =
    FilterParams(
      category: Some("nonexistent"),
      min_protein: None,
      max_protein: None,
      min_fat: None,
      max_fat: None,
      min_carbs: None,
      max_carbs: None,
      min_calories: None,
      max_calories: None,
    )

  let filtered = recipe_filter.filter_recipes(recipes, params)

  list.length(filtered) |> should.equal(0)
}

// ============================================================================
// Helper function to count matching recipes
// ============================================================================

fn count_matching_manually(
  recipes: List(FilteredRecipeItem),
  matches_fn: fn(FilteredRecipeItem) -> Bool,
) -> Int {
  recipes
  |> list.filter(matches_fn)
  |> list.length
}
