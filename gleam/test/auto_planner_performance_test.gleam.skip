/// Performance test: Meal plan generation with 100+ recipes
/// Tests auto planner performance with large recipe datasets
/// Benchmarks scoring, filtering, and selection algorithms
import gleeunit/should
import gleam/float
import gleam/int
import gleam/list
import meal_planner/auto_planner
import meal_planner/auto_planner/types as auto_types
import meal_planner/types.{
  type Recipe, Ingredient, Low, Macros, Recipe, activity_level_to_display_string,
  ActivityLevel, BalanceGoal, UserProfile,
}
import meal_planner/id

// ============================================================================
// Test Data Generation
// ============================================================================

/// Generate a synthetic recipe for benchmarking
/// Creates recipes with varying properties to simulate realistic data
fn create_test_recipe(index: Int) -> Recipe {
  let protein = 25.0 +. float.floor(int.to_float(index % 50) /. 2.0)
  let fat = 15.0 +. float.floor(int.to_float(index % 40) /. 2.0)
  let carbs = 45.0 +. float.floor(int.to_float(index % 60) /. 2.0)
  let is_vertical = index % 3 == 0

  Recipe(
    id: id.recipe_id("test_recipe_" <> int.to_string(index)),
    name: "Test Recipe #" <> int.to_string(index),
    ingredients: [
      Ingredient(
        id: "ing_" <> int.to_string(index),
        name: "Ingredient A",
        quantity: 100.0,
        unit: "g",
      ),
      Ingredient(
        id: "ing_" <> int.to_string(index + 1),
        name: "Ingredient B",
        quantity: 50.0,
        unit: "g",
      ),
    ],
    instructions: ["Mix", "Cook", "Serve"],
    macros: Macros(protein: protein, fat: fat, carbs: carbs),
    servings: 2,
    category: case index % 5 {
      0 -> "Protein"
      1 -> "Vegetable"
      2 -> "Grain"
      3 -> "Dairy"
      _ -> "Fruit"
    },
    fodmap_level: Low,
    vertical_compliant: is_vertical,
  )
}

/// Generate a list of N test recipes
/// Used to simulate realistic recipe datasets
fn generate_recipe_dataset(count: Int) -> List(Recipe) {
  list.range(0, count)
  |> list.map(create_test_recipe)
}

/// Create a test auto planner config
/// Standardized configuration for performance testing
fn create_test_config(recipe_count: Int) -> auto_types.AutoPlanConfig {
  auto_types.AutoPlanConfig(
    recipe_count: recipe_count,
    diet_principles: [],
    macro_targets: Macros(protein: 150.0, fat: 70.0, carbs: 200.0),
    variety_factor: 1.0,
  )
}

/// Create a test user profile
fn create_test_profile() -> UserProfile {
  UserProfile(
    id: "user_1",
    bodyweight: 80.0,
    activity_level: ActivityLevel.Moderate,
    goal: BalanceGoal.Maintenance,
    preferences: "",
  )
}

// ============================================================================
// Performance Tests
// ============================================================================

/// Benchmark: Filter recipes by diet principles (100 recipes)
pub fn auto_planner_filter_100_recipes_test() {
  let recipes = generate_recipe_dataset(100)
  let principles = [auto_types.VerticalDiet]

  let filtered = auto_planner.filter_by_diet_principles(recipes, principles)

  // Expect roughly 33% to be vertical compliant (index % 3 == 0)
  let filtered_count = list.length(filtered)
  should.be_true(filtered_count > 0)
  should.be_true(filtered_count < 100)
}

/// Benchmark: Filter recipes by diet principles (500 recipes)
pub fn auto_planner_filter_500_recipes_test() {
  let recipes = generate_recipe_dataset(500)
  let principles = [auto_types.VerticalDiet]

  let filtered = auto_planner.filter_by_diet_principles(recipes, principles)

  let filtered_count = list.length(filtered)
  should.be_true(filtered_count > 0)
  should.be_true(filtered_count < 500)
}

/// Benchmark: Score recipes (100 recipes)
pub fn auto_planner_score_100_recipes_test() {
  let recipes = generate_recipe_dataset(100)
  let config = create_test_config(5)

  let scored_recipes =
    list.map(recipes, fn(r) { auto_planner.score_recipe(r, config, []) })

  let count = list.length(scored_recipes)
  should.equal(count, 100)

  // Verify scoring produces valid scores
  let all_valid =
    list.all(scored_recipes, fn(sr) {
      sr.overall_score >=. 0.0 && sr.overall_score <=. 1.0
    })
  should.be_true(all_valid)
}

/// Benchmark: Score recipes (500 recipes)
pub fn auto_planner_score_500_recipes_test() {
  let recipes = generate_recipe_dataset(500)
  let config = create_test_config(10)

  let scored_recipes =
    list.map(recipes, fn(r) { auto_planner.score_recipe(r, config, []) })

  let count = list.length(scored_recipes)
  should.equal(count, 500)

  // Verify all scores are in valid range
  let all_valid =
    list.all(scored_recipes, fn(sr) {
      sr.overall_score >=. 0.0 && sr.overall_score <=. 1.0
    })
  should.be_true(all_valid)
}

/// Benchmark: Select top N recipes from 100 candidates
pub fn auto_planner_select_from_100_test() {
  let recipes = generate_recipe_dataset(100)
  let config = create_test_config(5)

  let scored =
    list.map(recipes, fn(r) { auto_planner.score_recipe(r, config, []) })

  let selected = auto_planner.select_top_n(scored, 5, 1.0)

  should.equal(list.length(selected), 5)
}

/// Benchmark: Select top N recipes from 500 candidates
pub fn auto_planner_select_from_500_test() {
  let recipes = generate_recipe_dataset(500)
  let config = create_test_config(10)

  let scored =
    list.map(recipes, fn(r) { auto_planner.score_recipe(r, config, []) })

  let selected = auto_planner.select_top_n(scored, 10, 1.0)

  should.equal(list.length(selected), 10)
}

/// Benchmark: Full pipeline - Generate plan from 100 recipes
pub fn auto_planner_generate_plan_100_recipes_test() {
  let recipes = generate_recipe_dataset(100)
  let config = create_test_config(5)

  // Convert to mealie format for the function
  let mealie_recipes =
    list.map(recipes, recipe_to_mealie)

  let result = auto_planner.generate_auto_plan(mealie_recipes, config)

  case result {
    Ok(plan) -> {
      should.equal(list.length(plan.recipes), 5)
      // Verify macros are calculated
      should.be_true(plan.total_macros.protein >.  0.0)
    }
    Error(_) -> should.fail("Plan generation failed")
  }
}

/// Benchmark: Full pipeline - Generate plan from 200 recipes
pub fn auto_planner_generate_plan_200_recipes_test() {
  let recipes = generate_recipe_dataset(200)
  let config = create_test_config(10)

  let mealie_recipes =
    list.map(recipes, recipe_to_mealie)

  let result = auto_planner.generate_auto_plan(mealie_recipes, config)

  case result {
    Ok(plan) -> {
      should.equal(list.length(plan.recipes), 10)
      should.be_true(plan.total_macros.protein >. 0.0)
    }
    Error(_) -> should.fail("Plan generation failed")
  }
}

/// Benchmark: Full pipeline - Generate plan from 500 recipes
pub fn auto_planner_generate_plan_500_recipes_test() {
  let recipes = generate_recipe_dataset(500)
  let config = create_test_config(15)

  let mealie_recipes =
    list.map(recipes, recipe_to_mealie)

  let result = auto_planner.generate_auto_plan(mealie_recipes, config)

  case result {
    Ok(plan) -> {
      should.equal(list.length(plan.recipes), 15)
      should.be_true(plan.total_macros.protein >. 0.0)
    }
    Error(_) -> should.fail("Plan generation failed")
  }
}

/// Benchmark: Variety scoring impact - 100 recipes, high variety factor
pub fn auto_planner_variety_factor_high_test() {
  let recipes = generate_recipe_dataset(100)
  let config = create_test_config(8)

  let mealie_recipes =
    list.map(recipes, recipe_to_mealie)

  // High variety factor should emphasize category diversity
  let result = auto_planner.generate_auto_plan(mealie_recipes, config)

  case result {
    Ok(plan) -> {
      should.equal(list.length(plan.recipes), 8)
      // With high variety, we should have diverse categories
      let categories =
        list.map(plan.recipes, fn(r) { r.category })
      let unique_categories = list.unique(categories)
      should.be_true(list.length(unique_categories) >= 3)
    }
    Error(_) -> should.fail("Plan generation failed")
  }
}

/// Benchmark: Macro match accuracy with 200 recipes
pub fn auto_planner_macro_match_200_test() {
  let recipes = generate_recipe_dataset(200)
  let config = create_test_config(7)

  let mealie_recipes =
    list.map(recipes, recipe_to_mealie)

  let result = auto_planner.generate_auto_plan(mealie_recipes, config)

  case result {
    Ok(plan) -> {
      // Verify macros are within reasonable bounds
      let avg_protein = plan.total_macros.protein /. 7.0
      let avg_fat = plan.total_macros.fat /. 7.0
      let avg_carbs = plan.total_macros.carbs /. 7.0

      // Should be relatively balanced
      should.be_true(avg_protein >.  15.0)
      should.be_true(avg_fat >. 10.0)
      should.be_true(avg_carbs >. 30.0)
    }
    Error(_) -> should.fail("Plan generation failed")
  }
}

// ============================================================================
// Edge Cases
// ============================================================================

/// Edge case: Very large dataset (1000 recipes)
pub fn auto_planner_large_dataset_test() {
  let recipes = generate_recipe_dataset(1000)
  let config = create_test_config(20)

  let mealie_recipes =
    list.map(recipes, recipe_to_mealie)

  let result = auto_planner.generate_auto_plan(mealie_recipes, config)

  case result {
    Ok(plan) -> {
      should.equal(list.length(plan.recipes), 20)
      should.be_true(plan.total_macros.protein >. 0.0)
    }
    Error(_) -> should.fail("Plan generation failed with large dataset")
  }
}

/// Edge case: Minimal dataset (exactly meets requirement)
pub fn auto_planner_minimal_dataset_test() {
  let recipes = generate_recipe_dataset(5)
  let config = create_test_config(5)

  let mealie_recipes =
    list.map(recipes, recipe_to_mealie)

  let result = auto_planner.generate_auto_plan(mealie_recipes, config)

  case result {
    Ok(plan) -> {
      should.equal(list.length(plan.recipes), 5)
    }
    Error(_) -> should.fail("Plan generation failed with minimal dataset")
  }
}

/// Edge case: Insufficient recipes after filtering
pub fn auto_planner_insufficient_after_filter_test() {
  // Only 5 recipes total, none meet vertical diet requirement
  let recipes = generate_recipe_dataset(5)
    |> list.map(fn(r) { Recipe(..r, vertical_compliant: False) })

  let config =
    create_test_config(3)
    |> auto_types.AutoPlanConfig(
      ..,
      diet_principles: [auto_types.VerticalDiet],
    )

  let mealie_recipes =
    list.map(recipes, recipe_to_mealie)

  let result = auto_planner.generate_auto_plan(mealie_recipes, config)

  // Should fail with insufficient recipes message
  case result {
    Error(msg) -> {
      should.be_true(
        string.contains(msg, "Insufficient recipes"),
      )
    }
    Ok(_) -> should.fail("Should have failed with insufficient recipes")
  }
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Convert Recipe to MealieRecipe format
fn recipe_to_mealie(recipe: Recipe) -> meal_planner.mealie.types.MealieRecipe {
  meal_planner.mealie.types.MealieRecipe(
    id: recipe.id.id,
    name: recipe.name,
    slug: string.lowercase(recipe.name),
    image: None,
    recipeIngredient: list.map(recipe.ingredients, fn(ing) {
      meal_planner.mealie.types.MealieRecipeIngredient(
        id: ing.id,
        display: ing.name <> " " <> int.to_string(
          float.round(ing.quantity),
        ) <> ing.unit,
        quantity: ing.quantity,
        unit: meal_planner.mealie.types.UnitResponse(id: "1", name: ing.unit),
        food: meal_planner.mealie.types.Food(
          id: ing.id,
          name: ing.name,
          description: None,
          wikipedia: None,
        ),
      )
    }),
    recipeInstructions: list.map(recipe.instructions, fn(inst) {
      meal_planner.mealie.types.RecipeStep(
        id: "1",
        title: None,
        text: inst,
        ingredientGroups: [],
      )
    }),
    tags: [],
    yield: int.to_string(recipe.servings),
    nutrition: meal_planner.mealie.types.NutritionInfo(
      protein: recipe.macros.protein,
      fat: recipe.macros.fat,
      carbohydrates: recipe.macros.carbs,
      calories: 0.0,
      fiber: 0.0,
      sugar: 0.0,
      sodium: 0.0,
    ),
  )
}

// Import needed for string operations
import gleam/string
import gleam/option.{None}
