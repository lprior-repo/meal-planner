//// Meal logging UI components for the web server

import gleam/float
import gleam/int
import gleam/list
import gleam/string
import lustre/attribute
import lustre/element
import lustre/element/html
import wisp

import server/storage
import shared/types

/// Display the meal logging page with recipe selection
pub fn log_meal_page() -> wisp.Response {
  use conn <- storage.with_connection(storage.db_path)

  let recipes = case storage.get_all_recipes(conn) {
    Ok(r) -> r
    Error(_) -> []
  }

  let content = [
    page_header("Log Meal", "/dashboard"),
    html.div([attribute.class("log-meal")], [
      html.h2([], [element.text("Select a Recipe")]),
      html.div(
        [attribute.class("recipe-select-grid")],
        list.map(recipes, recipe_select_card),
      ),
    ]),
  ]

  wisp.html_response(render_page("Log Meal - Meal Planner", content), 200)
}

/// Recipe selection card for meal logging
fn recipe_select_card(recipe: types.Recipe) -> element.Element(msg) {
  html.a(
    [
      attribute.href("/log/" <> recipe.id),
      attribute.class("recipe-select-card"),
    ],
    [
      html.div([attribute.class("recipe-name")], [element.text(recipe.name)]),
      html.div([attribute.class("recipe-macros-preview")], [
        element.text(
          float_to_string(recipe.macros.protein)
          <> "P / "
          <> float_to_string(recipe.macros.fat)
          <> "F / "
          <> float_to_string(recipe.macros.carbs)
          <> "C",
        ),
      ]),
    ],
  )
}

/// Display the meal logging form for a specific recipe
pub fn log_meal_form(recipe_id: String) -> wisp.Response {
  use conn <- storage.with_connection(storage.db_path)

  case storage.get_recipe_by_id(conn, recipe_id) {
    Error(_) -> not_found_page()
    Ok(recipe) -> {
      let today = get_today_date()
      let content = [
        page_header("Log " <> recipe.name, "/log"),
        html.div([attribute.class("log-form")], [
          html.form(
            [
              attribute.method("POST"),
              attribute.action("/api/logs/create"),
              attribute.class("meal-log-form"),
            ],
            [
              // Hidden fields
              html.input([
                attribute.type_("hidden"),
                attribute.name("recipe_id"),
                attribute.value(recipe.id),
              ]),
              html.input([
                attribute.type_("hidden"),
                attribute.name("date"),
                attribute.value(today),
              ]),
              // Servings selector
              html.div([attribute.class("form-group")], [
                html.label([attribute.for("servings")], [
                  element.text("Servings"),
                ]),
                html.select(
                  [
                    attribute.id("servings"),
                    attribute.name("servings"),
                    attribute.class("form-select"),
                  ],
                  [
                    html.option([attribute.value("0.5")], "0.5"),
                    html.option(
                      [attribute.value("1.0"), attribute.selected(True)],
                      "1.0",
                    ),
                    html.option([attribute.value("1.5")], "1.5"),
                    html.option([attribute.value("2.0")], "2.0"),
                  ],
                ),
              ]),
              // Meal type dropdown
              html.div([attribute.class("form-group")], [
                html.label([attribute.for("meal_type")], [
                  element.text("Meal Type"),
                ]),
                html.select(
                  [
                    attribute.id("meal_type"),
                    attribute.name("meal_type"),
                    attribute.class("form-select"),
                  ],
                  [
                    html.option([attribute.value("breakfast")], "Breakfast"),
                    html.option([attribute.value("lunch")], "Lunch"),
                    html.option([attribute.value("dinner")], "Dinner"),
                    html.option([attribute.value("snack")], "Snack"),
                  ],
                ),
              ]),
              // Preview macros
              html.div([attribute.class("macro-preview")], [
                html.h3([], [element.text("Nutrition (1 Serving)")]),
                html.div([attribute.class("macro-grid")], [
                  macro_stat(
                    "Protein",
                    float_to_string(recipe.macros.protein) <> "g",
                  ),
                  macro_stat("Fat", float_to_string(recipe.macros.fat) <> "g"),
                  macro_stat(
                    "Carbs",
                    float_to_string(recipe.macros.carbs) <> "g",
                  ),
                  macro_stat(
                    "Calories",
                    float_to_string(types.macros_calories(recipe.macros)),
                  ),
                ]),
              ]),
              // Action buttons
              html.div([attribute.class("form-actions")], [
                html.button(
                  [
                    attribute.type_("submit"),
                    attribute.class("btn btn-primary"),
                  ],
                  [element.text("Log Meal")],
                ),
                html.a(
                  [attribute.href("/log"), attribute.class("btn btn-secondary")],
                  [element.text("Cancel")],
                ),
              ]),
            ],
          ),
        ]),
      ]

      wisp.html_response(
        render_page("Log " <> recipe.name <> " - Meal Planner", content),
        200,
      )
    }
  }
}

fn macro_stat(label: String, value: String) -> element.Element(msg) {
  html.div([attribute.class("macro-stat")], [
    html.span([attribute.class("macro-label")], [element.text(label)]),
    html.span([attribute.class("macro-value")], [element.text(value)]),
  ])
}

fn page_header(title: String, back_href: String) -> element.Element(msg) {
  html.header([attribute.class("page-header")], [
    html.a([attribute.href(back_href), attribute.class("back-link")], [
      element.text("â†"),
    ]),
    html.h1([], [element.text(title)]),
  ])
}

fn render_page(title: String, content: List(element.Element(msg))) -> String {
  let body =
    html.html([attribute.attribute("lang", "en")], [
      html.head([], [
        html.meta([attribute.attribute("charset", "UTF-8")]),
        html.meta([
          attribute.name("viewport"),
          attribute.attribute(
            "content",
            "width=device-width, initial-scale=1.0",
          ),
        ]),
        html.title([], title),
        html.link([
          attribute.rel("stylesheet"),
          attribute.href("/static/styles.css"),
        ]),
      ]),
      html.body([], [html.div([attribute.class("container")], content)]),
    ])

  "<!DOCTYPE html>" <> element.to_string(body)
}

fn not_found_page() -> wisp.Response {
  let content = [
    html.div([attribute.class("not-found")], [
      html.h1([], [element.text("404")]),
      html.p([], [element.text("Page not found")]),
      html.a([attribute.href("/"), attribute.class("btn")], [
        element.text("Go Home"),
      ]),
    ]),
  ]

  wisp.html_response(render_page("Not Found - Meal Planner", content), 404)
}

fn float_to_string(f: Float) -> String {
  let rounded = float.round(f)
  int.to_string(rounded)
}

fn get_today_date() -> String {
  let #(#(year, month, day), _) = erlang_local_time()
  int.to_string(year) <> "-" <> pad_int(month) <> "-" <> pad_int(day)
}

fn pad_int(i: Int) -> String {
  let s = int.to_string(i)
  case string.length(s) {
    1 -> "0" <> s
    _ -> s
  }
}

@external(erlang, "calendar", "local_time")
fn erlang_local_time() -> #(#(Int, Int, Int), #(Int, Int, Int))
