fn dashboard_page(req: wisp.Request) -> wisp.Response {
  // Get filter from query parameter
  let filter = case wisp.get_query(req) {
    Ok(query) -> {
      case list.key_find(query, "filter") {
        Ok(f) -> f
        Error(_) -> "all"
      }
    }
    Error(_) -> "all"
  }

  let profile = sample_profile()
  let daily_log = sample_daily_log()
  let targets = types.daily_macro_targets(profile)

  // Filter entries by meal type
  let filtered_entries = filter_entries_by_meal_type(daily_log.entries, filter)
  let current = types.macros_sum(list.map(filtered_entries, fn(e) { e.macros }))

  let content = [
    page_header("Dashboard", "/"),
    html.div([attribute.class("dashboard")], [
      // Date
      html.p([attribute.class("date")], [element.text(daily_log.date)]),
      // Meal type filter
      html.div([attribute.class("meal-type-filter")], [
        html.span([attribute.class("filter-label")], [element.text("Filter: ")]),
        filter_button("All", "all", filter),
        filter_button("Breakfast", "breakfast", filter),
        filter_button("Lunch", "lunch", filter),
        filter_button("Dinner", "dinner", filter),
        filter_button("Snack", "snack", filter),
      ]),
      // Calorie summary
      html.div([attribute.class("calorie-summary")], [
        html.div([attribute.class("calorie-current")], [
          html.span([attribute.class("big-number")], [
            element.text(float_to_string(types.macros_calories(current))),
          ]),
          html.span([], [element.text(" / ")]),
          html.span([], [
            element.text(float_to_string(types.macros_calories(targets))),
          ]),
          html.span([attribute.class("unit")], [element.text(" cal")]),
        ]),
      ]),
      // Macro bars
      html.div([attribute.class("macro-bars")], [
        macro_bar("Protein", current.protein, targets.protein, "#28a745"),
        macro_bar("Fat", current.fat, targets.fat, "#ffc107"),
        macro_bar("Carbs", current.carbs, targets.carbs, "#17a2b8"),
      ]),
      // Meal entries
      html.div([attribute.class("meal-entries")], [
        html.h3([], [element.text("Today's Meals")]),
        case list.is_empty(filtered_entries) {
          True ->
            html.p([attribute.class("no-entries")], [
              element.text("No meals logged yet."),
            ])
          False ->
            html.div(
              [attribute.class("entries-list")],
              list.map(filtered_entries, meal_entry_card),
            )
        },
      ]),
      // Quick actions
      html.div([attribute.class("quick-actions")], [
        html.a([attribute.href("/log"), attribute.class("btn")], [
          element.text("Add Meal"),
        ]),
      ]),
    ]),
  ]

  wisp.html_response(render_page("Dashboard - Meal Planner", content), 200)
}

/// Create a filter button for meal type filtering
fn filter_button(
  label: String,
  filter_value: String,
  current_filter: String,
) -> element.Element(msg) {
  let is_active = filter_value == current_filter
  let class = case is_active {
    True -> "filter-btn active"
    False -> "filter-btn"
  }

  html.a(
    [attribute.href("/dashboard?filter=" <> filter_value), attribute.class(class)],
    [element.text(label)],
  )
}

/// Filter meal entries by meal type
fn filter_entries_by_meal_type(
  entries: List(types.FoodLogEntry),
  filter: String,
) -> List(types.FoodLogEntry) {
  case filter {
    "all" -> entries
    "breakfast" ->
      list.filter(entries, fn(e) { e.meal_type == types.Breakfast })
    "lunch" -> list.filter(entries, fn(e) { e.meal_type == types.Lunch })
    "dinner" -> list.filter(entries, fn(e) { e.meal_type == types.Dinner })
    "snack" -> list.filter(entries, fn(e) { e.meal_type == types.Snack })
    _ -> entries
  }
}

/// Display a single meal entry card
fn meal_entry_card(entry: types.FoodLogEntry) -> element.Element(msg) {
  html.div([attribute.class("meal-entry-card")], [
    html.div([attribute.class("meal-header")], [
      html.span([attribute.class("meal-type-badge")], [
        element.text(string.capitalise(types.meal_type_to_string(entry.meal_type))),
      ]),
      html.span([attribute.class("meal-name")], [element.text(entry.recipe_name)]),
    ]),
    html.div([attribute.class("meal-macros")], [
      element.text(
        float_to_string(entry.macros.protein)
        <> "P / "
        <> float_to_string(entry.macros.fat)
        <> "F / "
        <> float_to_string(entry.macros.carbs)
        <> "C ("
        <> float_to_string(types.macros_calories(entry.macros))
        <> " cal)",
      ),
    ]),
  ])
}
