# Contract Loop Flow - Self-healing code generation
#
# THE 4 LAWS:
# 1. No-Human Zone: AI writes code, humans write contracts
# 2. Contract is Law: Validation is draconian, self-heal on failure
# 3. We Set the Standard: Human defines target, AI hits it
# 4. Orchestrator Runs Everything: Windmill owns execution
#
# PATTERN: Generate -> Execute -> Validate -> (Pass=Exit | Fail=Feedback->Retry)
#
# WINDMILL FEATURES LEVERAGED:
# - forloopflow: Self-healing retry loop
# - Step retries: Exponential backoff for transient LLM failures
# - Error handler: Centralized failure notification
# - Caching: Skip redundant gate1 checks for identical code
# - Timeouts: Prevent runaway LLM/execution

summary: Contract-driven code generation with self-healing
description: |
  Generates code from a DataContract, executes it, validates output,
  and retries with feedback on failure. Escalates after max attempts.

schema:
  $schema: "https://json-schema.org/draft/2020-12/schema"
  type: object
  required:
    - contract_path
    - task
  properties:
    contract_path:
      type: string
      description: Path to DataContract YAML file
    task:
      type: string
      description: Natural language task description
    language:
      type: string
      default: rust
      enum: [rust, python, typescript, go]
      description: Target language for generation
    input_json:
      type: object
      default: {}
      description: JSON input for the generated code
    max_attempts:
      type: integer
      default: 5
      description: Maximum retry attempts before escalation
    model:
      type: string
      default: anthropic/claude-sonnet-4-20250514
      description: LLM model for generation
    dry_run:
      type: boolean
      default: false
      description: Skip actual generation/execution (for testing)

value:
  modules:
    # Initialize workspace
    - id: init
      value:
        type: script
        path: f/fire-flow/init/script

    # Main retry loop (using Windmill's for-loop)
    - id: retry_loop
      value:
        type: forloopflow
        iterator:
          type: javascript
          expr: "Array.from({length: flow_input.max_attempts}, (_, i) => i + 1)"
        skip_failures: true
        modules:
          # Generate code (with retries for transient LLM failures)
          - id: generate
            value:
              type: script
              path: f/fire-flow/generate/script
              # Exponential backoff: 3 retries, delays of 2s, 4s, 8s
              retry:
                constant:
                  attempts: 3
                  seconds: 2
                exponential:
                  attempts: 3
                  multiplier: 2
                  seconds: 2
              # 5 minute timeout for LLM generation
              timeout: 300
              input_transforms:
                contract_path:
                  type: javascript
                  expr: flow_input.contract_path
                task:
                  type: javascript
                  expr: flow_input.task
                language:
                  type: javascript
                  expr: flow_input.language
                feedback:
                  type: javascript
                  expr: results.init?.feedback || "Initial generation"
                attempt:
                  type: javascript
                  expr: "`${iter.value}/${flow_input.max_attempts}`"
                output_path:
                  type: javascript
                  expr: "`${results.init.work_dir}/generated_code.${flow_input.language === 'typescript' ? 'ts' : flow_input.language === 'python' ? 'py' : flow_input.language}`"
                model:
                  type: javascript
                  expr: flow_input.model
                dry_run:
                  type: javascript
                  expr: flow_input.dry_run
                trace_id:
                  type: javascript
                  expr: results.init.trace_id

          # Gate 1: Syntax Check (Parse + Lint + Type)
          # Cached for 1 hour - same code = same result
          - id: gate1
            value:
              type: script
              path: f/fire-flow/gate1/script
              cache_ttl: 3600
              timeout: 60
              input_transforms:
                code_path:
                  type: javascript
                  expr: results.generate.output_path
                language:
                  type: javascript
                  expr: flow_input.language
                dry_run:
                  type: javascript
                  expr: flow_input.dry_run
                trace_id:
                  type: javascript
                  expr: results.init.trace_id

          # Check Gate 1 result - skip to feedback if failed
          - id: check_gate1
            value:
              type: script
              path: f/fire-flow/check_gate1/script
              input_transforms:
                passed:
                  type: javascript
                  expr: results.gate1.passed
                errors:
                  type: javascript
                  expr: results.gate1.errors || []
            stop_after_if:
              expr: "result.status === 'failed'"
              skip_if_stopped: false

          # Execute generated code (with timeout to prevent runaway)
          - id: execute
            value:
              type: script
              path: f/fire-flow/execute/script
              # 2 minute timeout - code should execute fast
              timeout: 120
              input_transforms:
                code_path:
                  type: javascript
                  expr: results.generate.output_path
                language:
                  type: javascript
                  expr: flow_input.language
                code_input:
                  type: javascript
                  expr: flow_input.input_json
                output_path:
                  type: javascript
                  expr: "`${results.init.work_dir}/output.json`"
                logs_path:
                  type: javascript
                  expr: "`${results.init.work_dir}/logs.txt`"
                dry_run:
                  type: javascript
                  expr: flow_input.dry_run
                trace_id:
                  type: javascript
                  expr: results.init.trace_id

          # Validate output
          - id: validate
            value:
              type: script
              path: f/fire-flow/validate/script
              input_transforms:
                contract_path:
                  type: javascript
                  expr: flow_input.contract_path
                output_path:
                  type: javascript
                  expr: results.execute.output_path
                dry_run:
                  type: javascript
                  expr: flow_input.dry_run
                trace_id:
                  type: javascript
                  expr: results.init.trace_id

          # Check if valid - break loop on success
          - id: check_valid
            value:
              type: script
              path: f/fire-flow/check_valid/script
              input_transforms:
                valid:
                  type: javascript
                  expr: results.validate.valid
                iter_value:
                  type: javascript
                  expr: iter.value
                output_path:
                  type: javascript
                  expr: results.execute.output_path
            stop_after_if:
              expr: "result.status === 'success'"
              skip_if_stopped: false

          # Collect feedback for retry
          - id: feedback
            value:
              type: script
              path: f/fire-flow/collect_feedback/script
              input_transforms:
                output_path:
                  type: javascript
                  expr: results.execute?.output_path || ""
                logs_path:
                  type: javascript
                  expr: results.execute?.logs_path || ""
                validation_errors:
                  type: javascript
                  expr: results.validate?.errors || results.check_gate1?.errors || []
                gate1_errors:
                  type: javascript
                  expr: results.gate1?.errors || []
                attempt:
                  type: javascript
                  expr: "`${iter.value}/${flow_input.max_attempts}`"
                max_attempts:
                  type: javascript
                  expr: flow_input.max_attempts

          # Update state for next iteration
          - id: update_state
            value:
              type: script
              path: f/fire-flow/update_state/script
              input_transforms:
                feedback:
                  type: javascript
                  expr: results.feedback.feedback
                iter_value:
                  type: javascript
                  expr: iter.value

    # Final result (after loop completes or breaks)
    - id: final_result
      value:
        type: script
        path: f/fire-flow/final_result/script
        input_transforms:
          loop_result:
            type: javascript
            expr: results.retry_loop || []
          max_attempts:
            type: javascript
            expr: flow_input.max_attempts

  # Error handler - called when any step fails unrecoverably
  failure_module:
    id: error_handler
    value:
      type: script
      path: f/fire-flow/error_handler/script
      input_transforms:
        error:
          type: javascript
          expr: error
        failed_step:
          type: javascript
          expr: error?.step || "unknown"
        flow_input:
          type: javascript
          expr: flow_input
